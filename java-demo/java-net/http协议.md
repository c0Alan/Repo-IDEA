# 请求

HTTP请求消息分为请求消息头以及请求实体内容两部分。请求消息头的第一行必须由以下三部分组成：
 请求的方法（GET、POST和HEAD等）。
 Web资源的路径（http://www.website.com/test/test.html中的/test/test.html
部分）。
HTTP协议的版本（HTTP/1.0或HTTP/1.1）。
在请求消息头的其他行是请求头字段。每一行的格式是：
"头字段" ":" "头字段的值"
请求头以一个空行结束。如下面上一个GET请求的例子：

```
GET / HTTP/1.1
Host: www.csdn.net
Connection: Keep-Alive
Accept: /
```



如果是POST请求，将要提交的实体内容放到消息头的空行后面，如下面是一个POST请求的例子：

```
POST /servlets-examples/servlet/RequestParamExample HTTP/1.1
Host: localhost:8888
Content-Length: 29
Connection: Close
firstname=Bill&lastname=Gates
```



在上面的请求消息中Content-Length表示请求内容的以字节为单位的长度（" firstname=Bill&lastname=Gates"的长度）。在使用POST方法时，这个字段必须提供，而且长度必须等于实体内容的长度，否则服务器将返回一个错误状态码。

# 响应

HTTP响应消息同样也分为消息头和实体内容两部分。HTTP的响应消息头和请求消息头类似；第一行是请求的结果，也就是说，在响应消息头的第一行表明了请求消息是否成功地获得了服务器上的Web资源。第一行必须由以下三部分组成：

1. 响应消息的HTTP版本。
  格式为HTTP/1.1或HTTP/1.0。这个版本号未必和请求消息头的版本号一致；这主要是
  因为，服务器未必支持HTTP请求中所描述的HTTP版本，如使用GET / HTTP/1.1去请求服务器，当服务器只支持HTTP1.0时，那么就会返回HTTP/1.0。

2. 状态码。
  这个状态码由三位的数字组成，分为五个档次。下面是HTTP1.1的响应码：
  （1）以1开头的数字(1xx)。
   临时请求状态码。由100和101组成。这类状态码并不经常使用，它们的作为主要是服务器为客户端返回的临时的状态。
  （2）以2开头的数字(2xx)。
   请求成功状态码。范围从200到206。其中最常用的是200，它表示客户端请求成功，服务器已经将所请求的Web资源返回到了客户端。其他的六个状态码类似，都表示请求成功，只是要指引客户端进和下一步的动作。如状态码206表示服务器只是返回了一部分请求资源，客户端要想获得全部的Web资源，必须继续发出HTTP请求。其他的响应码的含义可以参阅HTTP1.1的规范RFC2616。
  （3）以3开头的数字(3xx)。
   Web资源重定向状态码。范围从300到307。所有以3开头的状态码都以不同的原因和方式使Web资源改变了原来的URL。如302通过一个Location字段确定了Web资源改变URL后的位置。有了这种状态码，当某个网站或其他的Web资源的URL变化后，而访问这些Web资源的用户并不能即使知道变化后的URL；因此，可以在用户访问原来的URL时加一个302响应，使客户端自动去访问新的URL。
  （4）以4开头的数字(4xx)。
   客户端错误状态码。范围从400到417。也许没人希望看到这状态码。但它们确实在Internet上大量存在。当用户访问的Web资源不存在或是没有权限访问Web资源时，服务器将返回这类状态码。这类状态码中最常遇到的是400。当用户发送一个不存在的Web资源路径时（GET、POST和HEAD方法后面跟的路径），服务器就会返回这个状态码。
  （5）以5开头的数字(5xx)。
  服务器错误状态码。范围从500到505。这类状态码也是一类错误状态码，只是它和4xx不同的是，5xx的错误是由于服务器的原因而产生的；如用户向服务器发送一个HTTP协议不支持的方法，如GET1，服务器将返回501错误，表示服务器不支持这个HTTP请求方法。

3. 状态信息。
  响应信息的内容和状态码息息相关。如状态码为200，则状态信息为"OK"。状态码为501，状态信息为"Not Implemented"。要想详细了解每一个状态码所对应的状态信息，请参阅HTTP1.1的规范RFC2616。
  HTTP响应消息的其他部分和请求消息一样，也是由很多响应头字段组成，每个字段和字段值占一行。响应消息头使用一个空行结束，空行的后面跟着HTTP响应消息的实体内容。如下面是一个完整的HTTP请求和响应的例子：
  HTTP请求消息

  ```
  GET / HTTP/1.1
  Host:www.csdn.net
  HTTP响应消息
  HTTP/1.0 200 OK
  Content-Length: 132273
  Content-Type: text/html
  Content-Location: http://www.csdn.net/index.htm
  Last-Modified: Sun, 28 Jan 2007 09:20:00 GMT
  Accept-Ranges: bytes
  ETag: "eed72b7cbd42c71:1b0e"
  Server: Microsoft-IIS/6.0
  X-Powered-By: ASP.NET
  Date: Sun, 28 Jan 2007 09:23:26 GMT
  Age: 32
  X-Cache: HIT from cachebj244.csdn.net
  Connection: close
  <!DOCTYPE html 
  ... ...
  
  ```

  

# 方法

HTTP1.1除了支持持久连接外，还将HTTP1.0的请求方法从原来的三个(GET、POST和HEAD)扩展到了八个（OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE和CONNECT）。

# http 权威指南 目录

第一部分 HTTP：Web的基础
第1章 HTTP概述
1.1 HTTP——因特网的多媒体信使
1.2 Web客户端和服务器
1.3 资源
1.3.1 媒体类型
1.3.2 URI
1.3.3 URL
1.3.4 URN
1.4 事务
1.4.1 方法
1.4.2 状态码
1.4.3 Web页面中可以包含多个对象
1.5 报文
1.6 连接
1.6.1 TCP/IP
1.6.2 连接、IP地址及端口号
1.6.3 使用Telnet实例
1.7 协议版本
1.8 Web的结构组件
1.8.1 代理
1.8.2 缓存
1.8.3 网关
1.8.4 隧道
1.8.5 Agent代理
1.9 起始部分的结束语
1.10 更多信息
1.10.1 HTTP协议信息
1.10.2 历史透视
1.10.3 其他万维网信息

第2章 URL与资源
2.1 浏览因特网资源
2.2 URL的语法
2.2.1 方案——使用什么协议
2.2.2 主机与端口
2.2.3 用户名和密码
2.2.4 路径
2.2.5 参数
2.2.6 查询字符串
2.2.7 片段
2.3 URL快捷方式
2.3.1 相对URL
2.3.2 自动扩展URL
2.4 各种令人头疼的字符
2.4.1 URL字符集
2.4.2 编码机制
2.4.3 字符限制
2.4.4 另外一点说明
2.5 方案的世界
2.6 未来展望
2.7 更多信息

第3章 HTTP报文
3.1 报文流
3.1.1 报文流入源端服务器
3.1.2 报文向下游流动
3.2 报文的组成部分
3.2.1 报文的语法
3.2.2 起始行
3.2.3 首部
3.2.4 实体的主体部分
3.2.5 版本0.9的报文
3.3 方法
3.3.1 安全方法
3.3.2 GET
3.3.3 HEAD
3.3.4 PUT
3.3.5 POST
3.3.6 TRACE
3.3.7 OPTIONS
3.3.8 DELETE
3.3.9 扩展方法
3.4 状态码
3.4.1 100～199——信息性状态码
3.4.2 200～299——成功状态码
3.4.3 300～399——重定向状态码
3.4.4 400～499——客户端错误状态码
3.4.5 500～599——服务器错误状态码
3.5 首部
3.5.1 通用首部
3.5.2 请求首部
3.5.3 响应首部
3.5.4 实体首部
3.6 更多信息

第4章 连接管理
4.1 TCP连接
4.1.1 TCP的可靠数据管道
4.1.2 TCP流是分段的、由IP分组传送
4.1.3 保持TCP连接的正确运行
4.1.4 用TCP套接字编程
4.2 对TCP性能的考虑
4.2.1 HTTP事务的时延
4.2.2 性能聚焦区域
4.2.3 TCP连接的握手时延
4.2.4 延迟确认
4.2.5 TCP慢启动
4.2.6 Nagle算法与TCP_NODELAY
4.2.7 TIME_WAIT累积与端口耗尽
4.3 HTTP连接的处理
4.3.1 常被误解的Connection首部
4.3.2 串行事务处理时延
4.4 并行连接
4.4.1 并行连接可能会提高页面的加载速度
4.4.2 并行连接不一定更快
4.4.3 并行连接可能让人“感觉”更快一些
4.5 持久连接
4.5.1 持久以及并行连接
4.5.2 HTTP/1.0+ keep-alive连接
4.5.3 Keep-Alive操作
4.5.4 Keep-Alive选项
4.5.5 Keep-Alive连接的限制和规则
4.5.6 Keep-Alive和哑代理
4.5.7 插入Proxy-Connection
4.5.8 HTTP/1.1持久连接
4.5.9 持久连接的限制和规则
4.6 管道化连接
4.7 关闭连接的奥秘
4.7.1 “任意”解除连接
4.7.2 Content-Length及截尾操作
4.7.3 连接关闭容限、重试以及幂等性
4.7.4 正常关闭连接
4.8 更多信息
4.8.1 HTTP连接
4.8.2 HTTP性能问题
4.8.3 TCP/IP

第二部分 HTTP结构
第5章 Web服务器
5.1 各种形状和尺寸的Web服务器
5.1.1 Web服务器的实现
5.1.2 通用软件Web服务器
5.1.3 Web服务器设备
5.1.4 嵌入式Web服务器
5.2 最小的Perl Web服务器
5.3 实际的Web服务器会做些什么
5.4 第一步——接受客户端连接
5.4.1 处理新连接
5.4.2 客户端主机名识别
5.4.3 通过ident确定客户端用户
5.5 第二步——接收请求报文
5.5.1 报文的内部表示法
5.5.2 连接的输入/输出处理结构
5.6 第三步——处理请求
5.7 第四步——对资源的映射及访问
5.7.1 docroot
5.7.2 目录列表
5.7.3 动态内容资源的映射
5.7.4 服务器端包含项
5.7.5 访问控制
5.8 第五步——构建响应
5.8.1 响应实体
5.8.2 MIME类型
5.8.3 重定向
5.9 第六步——发送响应
5.10 第七步——记录日志
5.11 更多信息

第6章 代理
6.1 Web的中间实体
6.1.1 私有和共享代理
6.1.2 代理与网关的对比
6.2 为什么使用代理
6.3 代理会去往何处
6.3.1 代理服务器的部署
6.3.2 代理的层次结构
6.3.3 代理是如何获取流量的
6.4 客户端的代理设置
6.4.1 客户端的代理配置：手工配置
6.4.2 客户端代理配置：PAC文件
6.4.3 客户端代理配置：WPAD
6.5 与代理请求有关的一些棘手问题
6.5.1 代理URI与服务器URI的不同
6.5.2 与虚拟主机一样的问题
6.5.3 拦截代理会收到部分URI
6.5.4 代理既可以处理代理请求，也可以处理服务器请求
6.5.5 转发过程中对URI的修改
6.5.6 URI的客户端自动扩展和主机名解析
6.5.7 没有代理时URI的解析
6.5.8 有显式代理时URI的解析
6.5.9 有拦截代理时URI的解析
6.6 追踪报文
6.6.1 Via首部
6.6.2 TRACE方法
6.7 代理认证
6.8 代理的互操作性
6.8.1 处理代理不支持的首部和方法
6.8.2 OPTIONS：发现对可选特性的支持
6.8.3 Allow首部
6.9 更多信息

第7章 缓存
7.1 冗余的数据传输
7.2 带宽瓶颈
7.3 瞬间拥塞
7.4 距离时延
7.5 命中和未命中的
7.5.1 再验证
7.5.2 命中率
7.5.3 字节命中率
7.5.4 区分命中和未命中的情况
7.6 缓存的拓扑结构
7.6.1 私有缓存
7.6.2 公有代理缓存
7.6.3 代理缓存的层次结构
7.6.4 网状缓存、内容路由以及对等缓存
7.7 缓存的处理步骤
7.7.1 第一步——接收
7.7.2 第二步——解析
7.7.3 第三步——查找
7.7.4 第四步——新鲜度检测
7.7.5 第五步——创建响应
7.7.6 第六步——发送
7.7.7 第七步——日志
7.7.8 缓存处理流程图
7.8 保持副本的新鲜
7.8.1 文档过期
7.8.2 过期日期和使用期
7.8.3 服务器再验证
7.8.4 用条件方法进行再验证
7.8.5 If-Modified-Since：Date再验证
7.8.6 If-None-Match：实体标签再验证
7.8.7 强弱验证器
7.8.8 什么时候应该使用实体标签和最近修改日期
7.9 控制缓存的能力
7.9.1 no-Store与no-Cache响应首部
7.9.2 max-age响应首部
7.9.3 Expires响应首部
7.9.4 must-revalidate响应首部
7.9.5 试探性过期
7.9.6 客户端的新鲜度限制
7.9.7 注意事项
7.10 设置缓存控制
7.10.1 控制Apache的HTTP首部
7.10.2 通过HTTP-EQUIV控制HTML缓存
7.11 详细算法
7.11.1 使用期和新鲜生存期
7.11.2 使用期的计算
7.11.3 完整的使用期计算算法
7.11.4 新鲜生存期计算
7.11.5 完整的服务器——新鲜度算法
7.12 缓存和广告
7.12.1 发布广告者的两难处境
7.12.2 发布者的响应
7.12.3 日志迁移
7.12.4 命中计数和使用限制
7.13 更多信息

第8章 集成点：网关、隧道及中继
8.1 网关
8.2 协议网关
8.2.1 HTTP：服务器端Web网关
8.2.2 HTTP/HTTPS：服务器端安全网关
8.2.3 HTTPS/HTTP客户端安全加速器网关
8.3 资源网关
8.3.1 CGI
8.3.2 服务器扩展API
8.4 应用程序接口和Web服务
8.5 隧道
8.5.1 用CONNECT建立HTTP隧道
8.5.2 数据隧道、定时及连接管理
8.5.3 SSL隧道
8.5.4 SSL隧道与HTTP/HTTPS网关的对比
8.5.5 隧道认证
8.5.6 隧道的安全性考虑
8.6 中继
8.7 更多信息

第9章 Web 机器人
9.1 爬虫及爬行方式
9.1.1 从哪儿开始：根集
9.1.2 链接的提取以及相对链接的标准化
9.1.3 避免环路的出现
9.1.4 循环与复制
9.1.5 面包屑留下的痕迹
9.1.6 别名与机器人环路
9.1.7 规范化URL
9.1.8 文件系统连接环路
9.1.9 动态虚拟Web空间
9.1.10 避免循环和重复
9.2 机器人的HTTP
9.2.1 识别请求首部
9.2.2 虚拟主机
9.2.3 条件请求
9.2.4 对响应的处理
9.2.5 User-Agent导向
9.3 行为不当的机器人
9.4 拒绝机器人访问
9.4.1 拒绝机器人访问标准
9.4.2 Web站点和robots.txt文件
9.4.3 robots.txt文件的格式
9.4.4 其他有关robots.txt的知识
9.4.5 缓存和robots.txt的过期
9.4.6 拒绝机器人访问的Perl代码
9.4.7 HTML的robot-control元标签
9.5 机器人的规范
9.6 搜索引擎
9.6.1 大格局
9.6.2 现代搜索引擎结构
9.6.3 全文索引
9.6.4 发布查询请求
9.6.5 对结果进行排序，并提供查询结果
9.6.6 欺诈
9.7 更多信息

第10章 HTTP-NG
10.1 HTTP发展中存在的问题
10.2 HTTP-NG的活动
10.3 模块化及功能增强
10.4 分布式对象
10.5 第一层——报文传输
10.6 第二层——远程调用
10.7 第三层——Web应用
10.8 WebMUX
10.9 二进制连接协议
10.10 当前的状态
10.11 更多信息

第三部分 识别、认证与安全
第11章 客户端识别与cookie机制
11.1 个性化接触
11.2 HTTP首部
11.3 客户端IP地址
11.4 用户登录
11.5 胖URL
11.6 cookie
11.6.1 cookie的类型
11.6.2 cookie是如何工作的
11.6.3 cookie罐：客户端的状态
11.6.4 不同站点使用不同的cookie
11.6.5 cookie成分
11.6.6 cookies版本0（Netscape）
11.6.7 cookies版本1（RFC 2965）
11.6.8 cookie与会话跟踪
11.6.9 cookie与缓存
11.6.10 cookie、安全性和隐私
11.7 更多信息

第12章 基本认证机制
12.1 认证
12.1.1 HTTP的质询/响应认证框架
12.1.2 认证协议与首部
12.1.3 安全域
12.2 基本认证
12.2.1 基本认证实例
12.2.2 Base-64用户名/密码编码
12.2.3 代理认证
12.3 基本认证的安全缺陷
12.4 更多信息

第13章 摘要认证
13.1 摘要认证的改进
13.1.1 用摘要保护密码
13.1.2 单向摘要
13.1.3 用随机数防止重放攻击
13.1.4 摘要认证的握手机制
13.2 摘要的计算
13.2.1 摘要算法的输入数据
13.2.2 算法H（d）和KD（s，d）
13.2.3 与安全性相关的数据（A1）
13.2.4 与报文有关的数据（A2）
13.2.5 摘要算法总述
13.2.6 摘要认证会话
13.2.7 预授权
13.2.8 随机数的选择
13.2.9 对称认证
13.3 增强保护质量
13.3.1 报文完整性保护
13.3.2 摘要认证首部
13.4 应该考虑的实际问题
13.4.1 多重质询
13.4.2 差错处理
13.4.3 保护空间
13.4.4 重写URI
13.4.5 缓存
13.5 安全性考虑
13.5.1 首部篡改
13.5.2 重放攻击
13.5.3 多重认证机制
13.5.4 词典攻击
13.5.5 恶意代理攻击和中间人攻击
13.5.6 选择明文攻击
13.5.7 存储密码
13.6 更多信息

第14章 安全HTTP
14.1 保护HTTP 的安全
14.2 数字加密
14.2.1 密码编制的机制与技巧
14.2.2 密码
14.2.3 密码机
14.2.4 使用了密钥的密码
14.2.5 数字密码
14.3 对称密钥加密技术
14.3.1 密钥长度与枚举攻击
14.3.2 建立共享密钥
14.4 公开密钥加密技术
14.4.1 RSA
14.4.2 混合加密系统和会话密钥
14.5 数字签名
14.6 数字证书
14.6.1 证书的主要内容
14.6.2 X.509 v3证书
14.6.3 用证书对服务器进行认证
14.7 HTTPS——细节介绍
14.7.1 HTTPS概述
14.7.2 HTTPS方案
14.7.3 建立安全传输
14.7.4 SSL握手
14.7.5 服务器证书
14.7.6 站点证书的有效性
14.7.7 虚拟主机与证书
14.8 HTTPS客户端实例
14.8.1 OpenSSL
14.8.2 简单的HTTPS客户端
14.8.3 执行OpenSSL客户端
14.9 通过代理以隧道形式传输安全流量
14.10 更多信息
14.10.1 HTTP安全性
14.10.2 SSL与TLS
14.10.3 公开密钥基础设施
14.10.4 数字密码

第四部分 实体、编码和国际化
第15章 实体和编码
15.1 报文是箱子，实体是货物
15.2 Content-Length： 实体的大小
15.2.1 检测截尾
15.2.2 错误的Content-Length
15.2.3 Content-Length与持久连接
15.2.4 内容编码
15.2.5 确定实体主体长度的规则
15.3 实体摘要
15.4 媒体类型和字符集
15.4.1 文本的字符编码
15.4.2 多部分媒体类型
15.4.3 多部分表格提交
15.4.4 多部分范围响应
15.5 内容编码
15.5.1 内容编码过程
15.5.2 内容编码类型
15.5.3 Accept-Encoding首部
15.6 传输编码和分块编码
15.6.1 可靠传输
15.6.2 Transfer-Encoding首部
15.6.3 分块编码
15.6.4 内容编码与传输编码的结合
15.6.5 传输编码的规则
15.7 随时间变化的实例
15.8 验证码和新鲜度
15.8.1 新鲜度
15.8.2 有条件的请求与验证码
15.9 范围请求
15.10 差异编码
15.11 更多信息

第16章 国际化
16.1 HTTP对国际性内容的支持
16.2 字符集与HTTP
16.2.1 字符集是把字符转换为二进制码的编码
16.2.2 字符集和编码如何工作
16.2.3 字符集不对，字符就不对
16.2.4 标准化的MIME charset值
16.2.5 Content-Type首部和Charset首部以及META标志
16.2.6 Accept-Charset首部
16.3 多语言字符编码入门
16.3.1 字符集术语
16.3.2 字符集的命名很糟糕
16.3.3 字符
16.3.4 字形、连笔以及表示形式
16.3.5 编码后的字符集
16.3.6 字符编码方案
16.4 语言标记与HTTP
16.4.1 Content-Language首部
16.4.2 Accept-Language首部
16.4.3 语言标记的类型
16.4.4 子标记
16.4.5 大小写
16.4.6 IANA语言标记注册
16.4.7 第一个子标记——名字空间
16.4.8 第二个子标记——名字空间
16.4.9 其余子标记——名字空间
16.4.10 配置和语言有关的首选项
16.4.11 语言标记参考表
16.5 国际化的URI
16.5.1 全球性的可转抄能力与有意义的字符的较量
16.5.2 URI字符集合
16.5.3 转义和反转义
16.5.4 转义国际化字符
16.5.5 URI中的模态切换
16.6 其他需要考虑的地方
16.6.1 首部和不合规范的数据
16.6.2 日期
16.6.3 域名
16.7 更多信息
16.7.1 附录
16.7.2 互联网的国际化
16.7.3 国际标准

第17章 内容协商与转码
17.1 内容协商技术
17.2 客户端驱动的协商
17.3 服务器驱动的协商
17.3.1 内容协商首部集
17.3.2 内容协商首部中的质量值
17.3.3 随其他首部集而变化
17.3.4 Apache中的内容协商
17.3.5 服务器端扩展
17.4 透明协商
17.4.1 进行缓存与备用候选
17.4.2 Vary首部
17.5 转码
17.5.1 格式转换
17.5.2 信息综合
17.5.3 内容注入
17.5.4 转码与静态预生成的对比
17.6 下一步计划
17.7 更多信息

第五部分 内容发布与分发
第18章 Web主机托管
18.1 主机托管服务
18.2 虚拟主机托管
18.2.1 虚拟服务器请求缺乏主机信息
18.2.2 设法让虚拟主机托管正常工作
18.2.3 HTTP/1.1的Host首部
18.3 使网站更可靠
18.3.1 镜像的服务器集群
18.3.2 内容分发网络
18.3.3 CDN中的反向代理缓存
18.3.4 CDN中的代理缓存
18.4 让网站更快
18.5 更多信息

第19章 发布系统
19.1 FrontPage为支持发布而做的服务器扩展
19.1.1 FrontPage服务器扩展
19.1.2 FrontPage术语表
19.1.3 FrontPage的RPC协议
19.1.4 FrontPage的安全模型
19.2 WebDAV与协作写作
19.2.1 WebDAV的方法
19.2.2 WebDAV与XML
19.2.3 WebDAV首部集
19.2.4 WebDAV的锁定与防止覆写
19.2.5 LOCK方法
19.2.6 UNLOCK方法
19.2.7 属性和元数据
19.2.8 PROPFIND方法
19.2.9 PROPPATCH方法
19.2.10 集合与名字空间管理
19.2.11 MKCOL方法
19.2.12 DELETE方法
19.2.13 COPY与MOVE方法
19.2.14 增强的HTTP/1.1方法
19.2.15 WebDAV中的版本管理
19.2.16 WebDAV的未来发展
19.3 更多信息

第20章 重定向与负载均衡
20.1 为什么要重定向
20.2 重定向到何地
20.3 重定向协议概览
20.4 通用的重定向方法
20.4.1 HTTP重定向
20.4.2 DNS重定向
20.4.3 任播寻址
20.4.4 IP MAC转发
20.4.5 IP地址转发
20.4.6 网元控制协议
20.5 代理的重定向方法
20.5.1 显式浏览器配置
20.5.2 代理自动配置
20.5.3 Web代理自动发现协议
20.6 缓存重定向方法
20.7 因特网缓存协议
20.8 缓存阵列路由协议
20.9 超文本缓存协议
20.9.1 HTCP认证
20.9.2 设置缓存策略
20.10 更多信息

第21章 日志记录与使用情况跟踪
21.1 记录内容
21.2 日志格式
21.2.1 常见日志格式
21.2.2 组合日志格式
21.2.3 网景扩展日志格式
21.2.4 网景扩展2日志格式
21.2.5 Squid代理日志格式
21.3 命中率测量
21.3.1 概述
21.3.2 Meter首部
21.4 关于隐私的考虑
21.5 更多信息

第六部分 附录
附录A URI方案
附录B HTTP状态码
附录C HTTP首部参考
附录D MIME类型
附录E Base-64编码
附录F 摘要认证
附录G 语言标记
附录H MIME字符集注册表
索引